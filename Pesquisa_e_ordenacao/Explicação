Claro, vou ajustar o texto para um formato simples e direto, adequado para um arquivo `.txt`:

---

# Ordenação - Organização ou Classificação por Chave(s)

## Algoritmos de Ordenação Simples

### 1. Ordenação por Bolhas (Bubble Sort)
- **Descrição**: Compara pares adjacentes de elementos e os troca se estiverem na ordem errada. Repete o processo até que a lista esteja ordenada.
- **Estabilidade**: Estável (mantém a ordem relativa de elementos iguais).
- **Complexidade**:
  - **Tempo**: \(O(N^2)\) no pior e médio caso; \(O(N)\) no melhor caso (lista já ordenada).
  - **Espaço**: \(O(1)\) - Ordenação em memória principal.
- **Observações**: Intuitivo e fácil de implementar, mas ineficiente para listas grandes. No melhor caso, ainda realiza \(O(N)\) comparações e possíveis trocas.

### 2. Ordenação por Seleção (Selection Sort)
- **Descrição**: Encontra o menor (ou maior) elemento da lista e o coloca na posição correta, repetindo o processo para a sublista restante.
- **Estabilidade**: Instável (pode alterar a ordem relativa de elementos iguais).
- **Complexidade**:
  - **Tempo**: \(O(N^2)\) no pior, médio e melhor caso.
  - **Espaço**: \(O(1)\) - Ordenação em memória principal.
- **Observações**: Realiza exatamente \(N - 1\) trocas, independentemente do estado inicial da lista. Pode ser mais lento que o Bubble Sort para listas não ordenadas devido ao número fixo de comparações.

### 3. Ordenação por Inserção (Insertion Sort)
- **Descrição**: Constrói a lista ordenada um elemento de cada vez, pegando elementos da lista não ordenada e inserindo-os na posição correta da lista ordenada.
- **Estabilidade**: Estável (mantém a ordem relativa de elementos iguais).
- **Complexidade**:
  - **Tempo**: \(O(N^2)\) no pior caso; \(O(N)\) no melhor caso (lista quase ordenada).
  - **Espaço**: \(O(1)\) - Ordenação em memória principal.
- **Observações**: Eficiente para listas pequenas ou quase ordenadas. Realiza menos trocas em comparação com Bubble Sort e Selection Sort.

## Comparação de Complexidades

- **Tempo**:
  - **Melhor Caso**: Bubble Sort e Insertion Sort podem ser mais eficientes com listas quase ordenadas. No entanto, mesmo o melhor caso do Bubble Sort ainda requer \(O(N)\) comparações.
  - **Pior Caso**: Todos os algoritmos simples têm complexidade \(O(N^2)\), tornando-os ineficientes para grandes conjuntos de dados.

- **Espaço**:
  - Todos os algoritmos têm complexidade de espaço \(O(1)\), utilizando uma quantidade constante de espaço adicional além da entrada.

## Complexidade = Esforço Computacional

O esforço computacional é medido pela quantidade de comparações e trocas necessárias para ordenar a lista:
- **Comparações**: Quantas vezes os elementos são comparados para determinar a ordem.
- **Trocas**: Quantas vezes os elementos são trocados de posição.

## Considerações Adicionais

- **Estabilidade**: Algoritmos estáveis são preferidos para preservar a ordem relativa de elementos iguais.
- **Eficiência para Listas Grandes**: Algoritmos como Merge Sort e Quick Sort, com complexidade média de \(O(N \log N)\), são mais adequados para grandes listas. Heap Sort é outra opção eficiente para grandes conjuntos de dados, mesmo que seja menos estável.
